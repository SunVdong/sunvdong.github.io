<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Chan - 标签 - 我的灵感记录</title><link>https://www.vdong.xyz/tags/chan/</link><description>Chan - 标签 - 我的灵感记录</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 23 Jul 2025 21:42:49 +0800</lastBuildDate><atom:link href="https://www.vdong.xyz/tags/chan/" rel="self" type="application/rss+xml"/><item><title>写一个循环缓冲区</title><link>https://www.vdong.xyz/posts/golang/%E5%86%99%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/</link><pubDate>Wed, 23 Jul 2025 21:42:49 +0800</pubDate><author><name>vdong</name></author><guid>https://www.vdong.xyz/posts/golang/%E5%86%99%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/</guid><description><![CDATA[<h2 id="背景" class="headerLink">
    <a href="#%e8%83%8c%e6%99%af" class="header-mark"></a>背景</h2><p>在解决 <a href="https://exercism.org/tracks/go/exercises/circular-buffer" target="_blank" rel="noopener noreferrer">这个问题</a> 时，遇到了 环形缓冲区（circular buffer）。可以解决这些原始需求：</p>
<ul>
<li>存储一系列<strong>按顺序到来的数据</strong></li>
<li>数据量可能很大，但我们不希望频繁申请/释放内存（例如不断扩容或移动）</li>
<li>只保留最近的 N 个数据项（例如音频缓冲、实时数据采集）</li>
<li>写入新数据时，如果满了，可以覆盖最旧的数据（可选）</li>
<li>高效读取数据，最好是常数时间复杂度</li>
</ul>
<p>**环形缓冲区（circular buffer）**是：</p>]]></description></item></channel></rss>