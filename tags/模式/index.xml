<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>模式 on 我的灵感记录</title><link>https://www.vdong.xyz/tags/%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 模式 on 我的灵感记录</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 26 May 2025 13:12:59 +0000</lastBuildDate><atom:link href="https://www.vdong.xyz/tags/%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>编码数据的格式</title><link>https://www.vdong.xyz/posts/ddia/%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/</link><pubDate>Fri, 16 Jun 2023 16:25:57 +0800</pubDate><guid>https://www.vdong.xyz/posts/ddia/%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/</guid><description>&lt;p>程序通常（至少）使用两种形式的数据：&lt;/p>
&lt;ol>
&lt;li>内存中，数据存储在对象、结构体、列表、数组、散列表、树等中。这些数据结构针对CPU的高效访问和操作做了优化（通常使用指针）。&lt;/li>
&lt;li>如果要将数据写入文件，或者通过网络发送，则必须将其 &lt;strong>编码（encode）&lt;/strong> 为某种自包含的字节序列（如：json文档）。由于每个进程都有自己的独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示 与 通常在内存中使用的数据结构完全不同 &lt;em>（除了一些特殊情况外，如某些内存映射文件或直接压缩数据上的操作）&lt;/em>。&lt;/li>
&lt;/ol>
&lt;p>所以，两者表示之间，需要进行某种类型的翻译。&lt;/p></description></item><item><title>模式与兼容</title><link>https://www.vdong.xyz/posts/ddia/%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9/</link><pubDate>Thu, 01 Jun 2023 11:00:42 +0800</pubDate><guid>https://www.vdong.xyz/posts/ddia/%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9/</guid><description>&lt;p>修改应用程序的功能也也意味着修改其存储的数据：使用新的字段或记录类型，或者以新的方式展示现有的数据。&lt;/p>
&lt;p>不同的数据模型有不同的方法应对这种变化：&lt;/p>
&lt;ul>
&lt;li>关系型数据库假定数据库中的所有数据都遵循一个模式：尽管可以更改这个模式（通过模式迁移，即 &lt;code>ALTER&lt;/code> 语句），但是在任何时间点都有且仅有一个正确的模式。&lt;/li>
&lt;li>&lt;strong>读时模式&lt;/strong>（schema-on-read，或 &lt;strong>无模式&lt;/strong>，即 schemaless）数据库不会强制一个模式，因此数据库可以包含在不同时间写入的新老数据格式的混合。&lt;/li>
&lt;/ul>
&lt;p>当数据 &lt;strong>格式（format）&lt;/strong> 或 &lt;strong>模式（schema）&lt;/strong> 发生变化时，通常需要对应用程序代码进行相应的更改（例如，为记录添加新字段，然后修改程序开始读写该字段）。但在大型应用程序中，代码变更通常不会立即完成：&lt;/p></description></item></channel></rss>